<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Parser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_parser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Parser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_parser_8h_source.html">Parser.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e658b5917a93a3ef648050d060e3a93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a3e658b5917a93a3ef648050d060e3a93">~Parser</a> ()</td></tr>
<tr class="separator:a3e658b5917a93a3ef648050d060e3a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a306c6c33d7a6cf1bb682be360fcfe982"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a306c6c33d7a6cf1bb682be360fcfe982">Parser</a> (char *buffer, char *cwd, int max_name_size)</td></tr>
<tr class="separator:a306c6c33d7a6cf1bb682be360fcfe982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada33680bf5f723ef95c44eeed1bff451"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#ada33680bf5f723ef95c44eeed1bff451">Parser</a> (std::string string, std::string cwd, int max_name_size)</td></tr>
<tr class="separator:ada33680bf5f723ef95c44eeed1bff451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5168f5c44e9649e71796f9bef48bdbbe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a5168f5c44e9649e71796f9bef48bdbbe">Parser</a> (const char *string_lit, const char *cwd, int max_name_size)</td></tr>
<tr class="separator:a5168f5c44e9649e71796f9bef48bdbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12234f6cd36b61af4b50c94a179422c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a12234f6cd36b61af4b50c94a179422c1">Parser</a> ()</td></tr>
<tr class="separator:a12234f6cd36b61af4b50c94a179422c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Mutators</div></td></tr>
<tr class="memitem:a87f5e73ca10ef5f84f37a4b37e0e6f59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a87f5e73ca10ef5f84f37a4b37e0e6f59">reset</a> (std::string string, std::string cwd=&quot;&quot;)</td></tr>
<tr class="memdesc:a87f5e73ca10ef5f84f37a4b37e0e6f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the member _string of the parser class to whatever is passed.  <a href="#a87f5e73ca10ef5f84f37a4b37e0e6f59">More...</a><br /></td></tr>
<tr class="separator:a87f5e73ca10ef5f84f37a4b37e0e6f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e097c301e171481e8d2af91c112e35e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a5e097c301e171481e8d2af91c112e35e">reset</a> (char *buffer, char *cwd=NULL)</td></tr>
<tr class="memdesc:a5e097c301e171481e8d2af91c112e35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the member _string of the parser class to whatever is passed.  <a href="#a5e097c301e171481e8d2af91c112e35e">More...</a><br /></td></tr>
<tr class="separator:a5e097c301e171481e8d2af91c112e35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51b81b1617f1948205d73804e3c0fb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#ab51b81b1617f1948205d73804e3c0fb9">reset</a> (const char *string_lit, const char *cwd=&quot;&quot;)</td></tr>
<tr class="memdesc:ab51b81b1617f1948205d73804e3c0fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the member _string of the parser class to whatever is passed.  <a href="#ab51b81b1617f1948205d73804e3c0fb9">More...</a><br /></td></tr>
<tr class="separator:ab51b81b1617f1948205d73804e3c0fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c3bf43a7f27f92ecf538b83c5984d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#ac9c3bf43a7f27f92ecf538b83c5984d6">set_max_name_size</a> (int size)</td></tr>
<tr class="memdesc:ac9c3bf43a7f27f92ecf538b83c5984d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum allowed file and tagname size that the <a class="el" href="class_parser.html">Parser</a> will use.  <a href="#ac9c3bf43a7f27f92ecf538b83c5984d6">More...</a><br /></td></tr>
<tr class="separator:ac9c3bf43a7f27f92ecf538b83c5984d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086f1431a0cac193fb6ff4506ba5c701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a086f1431a0cac193fb6ff4506ba5c701">set_cwd</a> (std::string cwd)</td></tr>
<tr class="memdesc:a086f1431a0cac193fb6ff4506ba5c701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Current Working Directory that the <a class="el" href="class_parser.html">Parser</a> will use.  <a href="#a086f1431a0cac193fb6ff4506ba5c701">More...</a><br /></td></tr>
<tr class="separator:a086f1431a0cac193fb6ff4506ba5c701"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Private Helper Functions</div></td></tr>
<tr class="memitem:ac786ab202a25c76a069e124d1bdaa780"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#ac786ab202a25c76a069e124d1bdaa780">lunion</a> (std::string string)</td></tr>
<tr class="separator:ac786ab202a25c76a069e124d1bdaa780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09e013dcba70865bdff465a7dafba6a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#af09e013dcba70865bdff465a7dafba6a">lintersect</a> (std::string string)</td></tr>
<tr class="separator:af09e013dcba70865bdff465a7dafba6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5276b177af3258fdd2437134652f9df"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#ac5276b177af3258fdd2437134652f9df">matrix_multiply</a> (std::vector&lt; std::string &gt; v1, std::vector&lt; std::string &gt; v2)</td></tr>
<tr class="memdesc:ac5276b177af3258fdd2437134652f9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function which performs matrix multiplication on two std::vector's of std::string's Always multiplies the larger vector into the smaller vector unless the vectors are of equal size.  <a href="#ac5276b177af3258fdd2437134652f9df">More...</a><br /></td></tr>
<tr class="separator:ac5276b177af3258fdd2437134652f9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7cd45cdf0fe9f3420f26a54a946f56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a8e7cd45cdf0fe9f3420f26a54a946f56">parse_path</a> (std::vector&lt; std::string &gt; &amp;parsed)</td></tr>
<tr class="memdesc:a8e7cd45cdf0fe9f3420f26a54a946f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes unnescesarry information (such as the command flags), from a command string which is contains a "path".  <a href="#a8e7cd45cdf0fe9f3420f26a54a946f56">More...</a><br /></td></tr>
<tr class="separator:a8e7cd45cdf0fe9f3420f26a54a946f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7db54feacd1bff189de70135cd3216"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a6e7db54feacd1bff189de70135cd3216">parse_rename</a> (std::vector&lt; std::string &gt; &amp;parsed)</td></tr>
<tr class="memdesc:a6e7db54feacd1bff189de70135cd3216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the parsing of 'rename tag' commands.  <a href="#a6e7db54feacd1bff189de70135cd3216">More...</a><br /></td></tr>
<tr class="separator:a6e7db54feacd1bff189de70135cd3216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dff2c17612843df95b4ec6d4e4af847"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a4dff2c17612843df95b4ec6d4e4af847">parse_merge</a> (std::vector&lt; std::string &gt; &amp;parsed)</td></tr>
<tr class="memdesc:a4dff2c17612843df95b4ec6d4e4af847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the parsing of 'merge tag' commands.  <a href="#a4dff2c17612843df95b4ec6d4e4af847">More...</a><br /></td></tr>
<tr class="separator:a4dff2c17612843df95b4ec6d4e4af847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc03a0e1dbb6886981f024cb3957b09a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#abc03a0e1dbb6886981f024cb3957b09a">jump_to_char</a> (int &amp;index, char delim)</td></tr>
<tr class="memdesc:abc03a0e1dbb6886981f024cb3957b09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set index to the first instance of the requested char within a std::string.  <a href="#abc03a0e1dbb6886981f024cb3957b09a">More...</a><br /></td></tr>
<tr class="separator:abc03a0e1dbb6886981f024cb3957b09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c2ea3723b454b2627ecaf0fe7c88ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a69c2ea3723b454b2627ecaf0fe7c88ea">substr_to_char</a> (int &amp;index, std::string &amp;string, char delim)</td></tr>
<tr class="memdesc:a69c2ea3723b454b2627ecaf0fe7c88ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a std::string from a given index up until a chosen delimiting charachter Using another std::string as its base.  <a href="#a69c2ea3723b454b2627ecaf0fe7c88ea">More...</a><br /></td></tr>
<tr class="separator:a69c2ea3723b454b2627ecaf0fe7c88ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a172a2dcda0488c937d690755d9f4318c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a172a2dcda0488c937d690755d9f4318c">_string</a></td></tr>
<tr class="separator:a172a2dcda0488c937d690755d9f4318c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3439fb839047252a9c701532ab5f15a0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a3439fb839047252a9c701532ab5f15a0">_cwd</a></td></tr>
<tr class="separator:a3439fb839047252a9c701532ab5f15a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c955ec95d7c70515acae6d2e6ad88b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a77c955ec95d7c70515acae6d2e6ad88b">_max_name_size</a></td></tr>
<tr class="separator:a77c955ec95d7c70515acae6d2e6ad88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Public Accessors</h2></td></tr>
<tr class="memitem:a5b531e9ed867eeb8ccb9cb088cf35c24"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a5b531e9ed867eeb8ccb9cb088cf35c24">parse</a> (int type)</td></tr>
<tr class="memdesc:a5b531e9ed867eeb8ccb9cb088cf35c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string based on a certain rule.  <a href="#a5b531e9ed867eeb8ccb9cb088cf35c24">More...</a><br /></td></tr>
<tr class="separator:a5b531e9ed867eeb8ccb9cb088cf35c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa973764b863dfbe448fa2fd7aa9ffdaa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#aa973764b863dfbe448fa2fd7aa9ffdaa">get_cwd_tags</a> ()</td></tr>
<tr class="memdesc:aa973764b863dfbe448fa2fd7aa9ffdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector representation of the current working directory.  <a href="#aa973764b863dfbe448fa2fd7aa9ffdaa">More...</a><br /></td></tr>
<tr class="separator:aa973764b863dfbe448fa2fd7aa9ffdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c87961db9707dc18db00a645d3d1e5"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_parser.html#a71c87961db9707dc18db00a645d3d1e5">split_on_delim</a> (std::string string, char delim)</td></tr>
<tr class="memdesc:a71c87961db9707dc18db00a645d3d1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string at each instance of a particualar char (the delimeter)  <a href="#a71c87961db9707dc18db00a645d3d1e5">More...</a><br /></td></tr>
<tr class="separator:a71c87961db9707dc18db00a645d3d1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a306c6c33d7a6cf1bb682be360fcfe982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306c6c33d7a6cf1bb682be360fcfe982">&#9670;&nbsp;</a></span>Parser() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parser::Parser </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>cwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_name_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>name Constructors;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A C-Style String representation of the string to be parsed</td></tr>
    <tr><td class="paramname">cwd</td><td>A C-Style String representation of the current working directory; (This value is typically provided by the Liaison process). The directory string is used to parse commands which act within directories only thus providing commands such as 'tag' a "path" to the file(s) which will be tagged without the user having to explicitly enter those file's entire paths themselves.</td></tr>
    <tr><td class="paramname">max_name_size</td><td>The maximum length that a file or tagname is allowed to have; (This value is typically provided by the Liaison process) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada33680bf5f723ef95c44eeed1bff451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada33680bf5f723ef95c44eeed1bff451">&#9670;&nbsp;</a></span>Parser() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parser::Parser </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>cwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_name_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A std::string representation of the string to be parsed</td></tr>
    <tr><td class="paramname">cwd</td><td>A std::string representation of the current working directory; (This value is typically provided by the Liaison process). The directory string is used to parse commands which act within directories only thus, providing commands such as 'tag' a "path" to the file(s) which will be tagged without the user having to explicitly enter those file's entire paths themselves.</td></tr>
    <tr><td class="paramname">max_name_size</td><td>The maximum length that a file or tagname is allowed to have; (This value is typically provided by the Liaison process) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5168f5c44e9649e71796f9bef48bdbbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5168f5c44e9649e71796f9bef48bdbbe">&#9670;&nbsp;</a></span>Parser() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parser::Parser </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_lit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_name_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A String Literal representation of the string to be parsed</td></tr>
    <tr><td class="paramname">cwd</td><td>A String Literal representation of the current working directory; (This value is typically provided by the Liaison process). The directory string is used to parse commands which act within directories only thus, providing commands such as 'tag' a "path" to the file(s) which will be tagged without the user having to explicitly enter those file's entire paths themselves.</td></tr>
    <tr><td class="paramname">max_name_size</td><td>The maximum length that a file or tagname is allowed to have; (This value is typically provided by the Liaison process) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12234f6cd36b61af4b50c94a179422c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12234f6cd36b61af4b50c94a179422c1">&#9670;&nbsp;</a></span>Parser() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parser::Parser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default Constructor to be used in case initialization of values needs to be done elsewhere </p>

</div>
</div>
<a id="a3e658b5917a93a3ef648050d060e3a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e658b5917a93a3ef648050d060e3a93">&#9670;&nbsp;</a></span>~Parser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parser::~Parser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default Destructor; Does nothing </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa973764b863dfbe448fa2fd7aa9ffdaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa973764b863dfbe448fa2fd7aa9ffdaa">&#9670;&nbsp;</a></span>get_cwd_tags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Parser::get_cwd_tags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector representation of the current working directory. </p>
<p>That is, it will decompose '/string1/string2' into a vector containing [string1, string2]. This is useful when the calling code requires the current working directory as a vector of strings rather than as a standard string representation.</p>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of std::string comprised of the non-'/' parts of the <a class="el" href="class_parser.html">Parser</a> member value _cwd </dd></dl>

</div>
</div>
<a id="abc03a0e1dbb6886981f024cb3957b09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc03a0e1dbb6886981f024cb3957b09a">&#9670;&nbsp;</a></span>jump_to_char()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::jump_to_char </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set index to the first instance of the requested char within a std::string. </p>
<p>Because fast forwarding to a specific index (for example in order to skip command flags or other unimportant data (to the parser anyway)) is such a common need, this function was made in order to reduce code duplication. It use the member _string as the std::string it operates on and will return the index within the std::string at which the chose delimeter occurs. It DOES NOT modify the underling string in any way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A reference to a variable that will be incremented as the function operates</td></tr>
    <tr><td class="paramname">delim</td><td>A char value which will function as the delimeter at which the function will stop</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<a id="af09e013dcba70865bdff465a7dafba6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09e013dcba70865bdff465a7dafba6a">&#9670;&nbsp;</a></span>lintersect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Parser::lintersect </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to recursively decompose commands of the form 'command {s1,s2,..}'. Is also instrumental in the parsing of 'find' commands in instances were the find command includes list notation (e.g. 'find {s1,[s2,s3],...}').</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>A std::string representation of the string which will be decomposed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of std::string representing the decomposed string </dd></dl>

</div>
</div>
<a id="ac786ab202a25c76a069e124d1bdaa780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac786ab202a25c76a069e124d1bdaa780">&#9670;&nbsp;</a></span>lunion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Parser::lunion </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to recursively decompose commands of the form 'command [s1,s2,..]'. Is also instrumental in the parsing of 'find' commands in instances were the find command includes set notation (e.g. 'find [s1,{s2,s3},...]').</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>A std::string representation of the string which will be decomposed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of std::string representing the decomposed string </dd></dl>

</div>
</div>
<a id="ac5276b177af3258fdd2437134652f9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5276b177af3258fdd2437134652f9df">&#9670;&nbsp;</a></span>matrix_multiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Parser::matrix_multiply </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function which performs matrix multiplication on two std::vector's of std::string's Always multiplies the larger vector into the smaller vector unless the vectors are of equal size. </p>
<p>Used to create strings for 'find' commands which are of the form '{s1,[s2,s3],...}'. The '{}' construction is an &amp;&amp; construction, that is, it finds all files tagged with ALL of the strings within the braces. However, the '[]' construction is an || construction and finds all files tagged with ANY of the strings vithin the brackets. This means that a construction like '{s1,[s2,s3],s4..}' must find files tagged with: {s1,s2,s4..}, {s1,s3,s4..} the best way to achieve these results is to matrix multiply the vector returned by <a class="el" href="class_parser.html#ac786ab202a25c76a069e124d1bdaa780">lunion()</a> (which handles '[]' constructions) and <a class="el" href="class_parser.html#af09e013dcba70865bdff465a7dafba6a">lintersect()</a> (which handles '{}' constructions). Note that this has cubic time comlexity and so should be used sparingly for very large vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>One of the std::vector's of std::string's that will be multiplied </td></tr>
    <tr><td class="paramname">v2</td><td>The other of the std::vector's of std::string's that will be multiplied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of std::string's representing the matrix multiplication of v1 &amp; v2 </dd></dl>

</div>
</div>
<a id="a5b531e9ed867eeb8ccb9cb088cf35c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b531e9ed867eeb8ccb9cb088cf35c24">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Parser::parse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a string based on a certain rule. </p>
<p>The rule generally corresponds to how a CLI command should be decomposed. <br />
For example the CLI command for finding files takes a list of files, hower the CLI itself does not support batch commands, therefore, the <a class="el" href="class_parser.html">Parser</a> will decompose the command into its constituent parts (i.e. a single file). <br />
This particular behavior is access by passing '8' as the "type" of decomposition that needs to take place (Note that this corresponds to the command's ID). <br />
However the <a class="el" href="class_parser.html">Parser</a> can be extended to support any rule whatsoever, so long as it is added to the <a class="el" href="class_parser.html">Parser</a>'s <a class="el" href="class_parser.html#a5b531e9ed867eeb8ccb9cb088cf35c24" title="Parse a string based on a certain rule. ">parse()</a> function switch statement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The integer identification of the parse rule that will be executed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of std::string comprised of the result after the chosen parse rule is executed. </dd></dl>

</div>
</div>
<a id="a4dff2c17612843df95b4ec6d4e4af847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dff2c17612843df95b4ec6d4e4af847">&#9670;&nbsp;</a></span>parse_merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::parse_merge </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parsed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the parsing of 'merge tag' commands. </p>
<p>The 'merge tags' commands have syntax that does not conorm well with the rest of the commands Therefore because of their uniqueness and in an effort to reduce "Walls of Text" they were separated into their own function. <a class="el" href="class_parser.html#a4dff2c17612843df95b4ec6d4e4af847" title="Handles the parsing of &#39;merge tag&#39; commands. ">parse_merge()</a> will decompose the command 'merge [t1,t2,...] =&gt; tx' into multiple single merge operations of the form 't1-tx', 't2-tx', etc. and add them to the vector that the <a class="el" href="class_parser.html">Parser</a> will return upon successful completion of <a class="el" href="class_parser.html#a5b531e9ed867eeb8ccb9cb088cf35c24" title="Parse a string based on a certain rule. ">parse()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parsed</td><td>A referance to the std::vector into which the reduced command will be added. In general this should be the std::vector that the <a class="el" href="class_parser.html">Parser</a> will return upon successful completion of <a class="el" href="class_parser.html#a5b531e9ed867eeb8ccb9cb088cf35c24" title="Parse a string based on a certain rule. ">parse()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e7cd45cdf0fe9f3420f26a54a946f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7cd45cdf0fe9f3420f26a54a946f56">&#9670;&nbsp;</a></span>parse_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::parse_path </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parsed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes unnescesarry information (such as the command flags), from a command string which is contains a "path". </p>
<p>For example, the command 'delete /tag1/tag2/file' would be reduced to '/tag1/tag2/file'</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parsed</td><td>A referance to the std::vector into which the reduced command will be added. In general this should be the std::vector that the <a class="el" href="class_parser.html">Parser</a> will return upon successful completion of <a class="el" href="class_parser.html#a5b531e9ed867eeb8ccb9cb088cf35c24" title="Parse a string based on a certain rule. ">parse()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<a id="a6e7db54feacd1bff189de70135cd3216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7db54feacd1bff189de70135cd3216">&#9670;&nbsp;</a></span>parse_rename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::parse_rename </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parsed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the parsing of 'rename tag' commands. </p>
<p>The 'rename tag' commands must decomposes two seperate lists and then join each value at index = x in either list together. That is, the value at index 1 in list 1 must be joined with the value at index 1 in list 2. parse_rname() performs this function and adds the result to the vector that the <a class="el" href="class_parser.html">Parser</a> will return upon the successful completion of <a class="el" href="class_parser.html#a5b531e9ed867eeb8ccb9cb088cf35c24" title="Parse a string based on a certain rule. ">parse()</a>, in the following format 'list1value-list2value'. In an effort to reduce "Walls of Text" and because of the uniqueness of this command, this particular algorithm was placed into its own function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parsed</td><td>A referance to the std::vector into which the reduced command will be added. In general this should be the std::vector that the <a class="el" href="class_parser.html">Parser</a> will return upon successful completion of <a class="el" href="class_parser.html#a5b531e9ed867eeb8ccb9cb088cf35c24" title="Parse a string based on a certain rule. ">parse()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<a id="a87f5e73ca10ef5f84f37a4b37e0e6f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f5e73ca10ef5f84f37a4b37e0e6f59">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::reset </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>cwd</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the member _string of the parser class to whatever is passed. </p>
<p>The <a class="el" href="class_parser.html">Parser</a> class conducts all operations on its member _string rather than requiring that a string value be passed to its <a class="el" href="class_parser.html#a5b531e9ed867eeb8ccb9cb088cf35c24" title="Parse a string based on a certain rule. ">parse()</a> method. This was done in order to make use of the class as streamlined as possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>A std::string representation of the string to be parsed</td></tr>
    <tr><td class="paramname">cwd</td><td>A std::string representation of the current working directory; Note that this argument is optional and allows the user to both reset the string the <a class="el" href="class_parser.html">Parser</a> will work with as well as the directory string the <a class="el" href="class_parser.html">Parser</a> will use. The directory string is used to parse commands which act within directories only thus providing commands such as 'tag' a "path" to the file(s) which will be tagged without the user having to explicitly enter those file's entire paths themselves. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e097c301e171481e8d2af91c112e35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e097c301e171481e8d2af91c112e35e">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::reset </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>cwd</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the member _string of the parser class to whatever is passed. </p>
<p>The <a class="el" href="class_parser.html">Parser</a> class conducts all operations on its member _string rather than requiring that a string value be passed to its <a class="el" href="class_parser.html#a5b531e9ed867eeb8ccb9cb088cf35c24" title="Parse a string based on a certain rule. ">parse()</a> method. This was done in order to make use of the class as streamlined as possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>A C-Style String representation of the string to be parsed</td></tr>
    <tr><td class="paramname">cwd</td><td>A C-Style String representation of the current working directory; Note that this argument is optional and allows the user to both reset the string the <a class="el" href="class_parser.html">Parser</a> will work with as well as the directory string the <a class="el" href="class_parser.html">Parser</a> will use. The directory string is used to parse commands which act within directories only thus providing commands such as 'tag' a "path" to the file(s) which will be tagged without the user having to explicitly enter those file's entire paths themselves.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<a id="ab51b81b1617f1948205d73804e3c0fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51b81b1617f1948205d73804e3c0fb9">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::reset </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_lit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cwd</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the member _string of the parser class to whatever is passed. </p>
<p>The <a class="el" href="class_parser.html">Parser</a> class conducts all operations on its member _string rather than requiring that a string value be passed to its <a class="el" href="class_parser.html#a5b531e9ed867eeb8ccb9cb088cf35c24" title="Parse a string based on a certain rule. ">parse()</a> method. This was done in order to make use of the class as streamlined as possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>A String Literal representation of the string to be parsed</td></tr>
    <tr><td class="paramname">cwd</td><td>A String Literal representation of the current working directory; Note that this argument is optional and allows the user to both reset the string the <a class="el" href="class_parser.html">Parser</a> will work with as well as the directory string the <a class="el" href="class_parser.html">Parser</a> will use. The directory string is used to parse commands which act within directories only thus providing commands such as 'tag' a "path" to the file(s) which will be tagged without the user having to explicitly enter those file's entire paths themselves.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<a id="a086f1431a0cac193fb6ff4506ba5c701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086f1431a0cac193fb6ff4506ba5c701">&#9670;&nbsp;</a></span>set_cwd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::set_cwd </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>cwd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Current Working Directory that the <a class="el" href="class_parser.html">Parser</a> will use. </p>
<p>The directory string is used to parse commands which act within directories only thus providing commands such as 'tag' a "path" to the file(s) which will be tagged without the user having to explicitly enter those file's entire paths themselves. This function does not have counterparts which tahe C-Style Strings or String Literals. This is because, in all situations, if the current working directory must be set using this method, it is highly likely that the calling code has a std::string representation of the current working directory rather than a representation in one of the other formats. If such functionality (C-Style Strings and others) is desired, extensibility is easy enough. Regardless the <a class="el" href="class_parser.html">Parser</a>'s _cwd member will always be a std::string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cwd</td><td>A std::string representation of the current working directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<a id="ac9c3bf43a7f27f92ecf538b83c5984d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c3bf43a7f27f92ecf538b83c5984d6">&#9670;&nbsp;</a></span>set_max_name_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::set_max_name_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum allowed file and tagname size that the <a class="el" href="class_parser.html">Parser</a> will use. </p>
<p>If this size is exceeded an error is thrown and the <a class="el" href="class_parser.html">Parser</a> will stop its current activities. This value is dictated by the CLI and is generally provided to the <a class="el" href="class_parser.html">Parser</a> by the Liaison Process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The maximum file/tag name length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71c87961db9707dc18db00a645d3d1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c87961db9707dc18db00a645d3d1e5">&#9670;&nbsp;</a></span>split_on_delim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Parser::split_on_delim </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a string at each instance of a particualar char (the delimeter) </p>
<p>The delimeters are NOT included anywhere in the resulting vector. This function is static and is mainly used outside the <a class="el" href="class_parser.html">Parser</a> in order to split values that the parser returned. This can happen because the complexity of certain commands does not allow the parser to fully decompose the string and instead it can only reorganize the command into a form which can be easily split later. It is important to note that this function does not differentiate between the number of delimeter charcters the string contains. That is, it will read the whole string and split it at any point where the delimeter is seen whether it is seen in 1 or 100 places.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>A std::string representation of whatever string needs to be split </td></tr>
    <tr><td class="paramname">delim</td><td>A char value representing where the string should be split </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69c2ea3723b454b2627ecaf0fe7c88ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c2ea3723b454b2627ecaf0fe7c88ea">&#9670;&nbsp;</a></span>substr_to_char()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::substr_to_char </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a std::string from a given index up until a chosen delimiting charachter Using another std::string as its base. </p>
<p>Because the process of creating substrings from starting at an arbitrary index and ending at a specific charachter is so common, this function was created in order to reduce code duplication. This function will generate a string from a given index up until a chosen delimiting charachter. It also saves the resulting end index. This function DOES NOT modify the underling std::string in any way and like other functions above, uses the member _string as its underlying std::string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A reference to a variable that will be incremented as the function operates. This serves as both the starting index and the will store the resulting index after the function completes.</td></tr>
    <tr><td class="paramname">string</td><td>A reference to a std::string that will be modified with a subset of the contents of the base string.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiting charachter which will mark the stopping point of the function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3439fb839047252a9c701532ab5f15a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3439fb839047252a9c701532ab5f15a0">&#9670;&nbsp;</a></span>_cwd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::_cwd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77c955ec95d7c70515acae6d2e6ad88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c955ec95d7c70515acae6d2e6ad88b">&#9670;&nbsp;</a></span>_max_name_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Parser::_max_name_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a172a2dcda0488c937d690755d9f4318c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172a2dcda0488c937d690755d9f4318c">&#9670;&nbsp;</a></span>_string</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::_string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>SharedHeaders/<a class="el" href="_parser_8h_source.html">Parser.h</a></li>
<li>SharedCPPFiles/<a class="el" href="_parser_8cpp.html">Parser.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
